#+TITLE: Physics and Engineering Formulas
#+AUTHOR: Jamaul Drew
#+DATE: 2024-06-13
* VARIABLES
#+BEGIN_SRC python :results output :exports both
import math
import numpy as np

# Define variables
area = 0.02  # Area (m^2)
area1 = 1.0  # Area 1 (m^2)
area2 = 0.5  # Area 2 (m^2)
mag_field_vec = np.array([0.1, 0, 0])  # Magnetic field vector (T)
diameter = 0.1  # Diameter (m)
delta_H = 0.001  # Change in Enthalpy (J)
delta_KE = 50  # Change in kinetic energy (J)
delta_PE = 40  # Change in potential energy (J)
delta_S = 0.001  # Change in Entropy (J/K)
youngs_modulus = 2.0e11  # Young's Modulus (Pa)
force = 50  # Force (N)
centripetal_force = 20  # Centripetal force (N)
moment_of_inertia = 0.0001  # Moment of inertia (m^4)
current = 2  # Current (A)
polar_moment_inertia = 0.00005  # Polar moment of inertia (m^4)
col_eff_len_factor = 1.0  # Column effective length factor
length_vec = np.array([1, 0, 0])  # Length vector (m)
moment = 100  # Moment (N·m)
num_turns = 100  # Number of turns
pressure = 101325  # Pressure (Pa)
heat_added = 300  # Heat added (J)
heat_input = 200  # Heat input (J)
radius = 100  # Radius (m)
resistance = 5  # Resistance (Ω)
gas_constant = 8.314  # Gas constant (J/(mol·K))
cold_temp = 300  # Cold temperature (K)
dry_bulb_temp = 80  # Dry-bulb temperature (°F)
high_temp = 500  # High temperature (K)
low_temp = 300  # Low temperature (K)
period = 0.02  # Period (s)
temperature = 273.15  # Temperature (K)
torque = 10  # Torque (N·m)
wet_bulb_temp = 60  # Wet-bulb temperature (°F)
internal_energy_change = 500  # Internal energy change (J)
work_output_in = 100  # Work input (J)
work_output_out = 100  # Work output (J)
acceleration = 9.8  # Acceleration (m/s^2)
angular_acceleration = 2  # Angular acceleration (rad/s^2)
base_length = 1  # Base length (m)
dist_to_neutral_axis = 0.05  # Distance to neutral axis (m)
spec_heat_capacity_cp = 4.18  # Specific heat capacity at constant pressure (J/(K·kg))
spec_heat_capacity_cv = 1.87  # Specific heat capacity at constant volume (J/(K·kg))
distance = 10  # Distance (m)
initial_temp = 273.15  # Initial temperature (K)
temp_difference = 10  # Temperature difference (K)
delta_length = 0.001  # Change in length (m)
delta_displacement = 1  # Change in displacement (m)
diff_length_vector = [1, 0, 0]  # Differential length element of current-carrying wire (m)
strain = 0.01  # Strain
vacuum_permittivity = 8.854e-12  # Vacuum permittivity (F/m)
lateral_strain = 0.005  # Lateral strain
longitudinal_strain = 0.01  # Longitudinal strain
frequency = 50  # Frequency (Hz)
gravity = 9.81  # Gravity (m/s^2)
gamma = 1.4  # Specific heat ratio
height = 10  # Height (m)
spring_constant = 100  # Spring constant (N/m)
coulomb_constant = 8.99e9  # Coulomb constant (N·m^2/C^2)
length = 0.1  # Length (m)
wavelength = 0.5  # Wavelength (m)
mass = 1.0  # Mass (kg)
viscosity = 0.02  # Viscosity (N·s/m^2)
permeability_free_space = 4 * math.pi * 1e-7  # Permeability of free space (T·m/A)
substance_amount = 1  # Amount of substance (mol)
refractive_index1 = 1.5  # Refractive index 1
refractive_index2 = 1.0  # Refractive index 2
second_deriv_conc = 2  # Second derivative of concentration (mol/m^3)
charge1 = 6  # Charge 1 (C)
charge2 = 3  # Charge 2 (C)
rad_dist_from_wire = 1.58  # Radius (m)
position_vector = [1.0, 2.0, 3.0]  # Position vector (m)
density = 1000  # Density (kg/m^3)
fluid_density = 1000  # Density (kg/m^3), assuming water
stress = 200  # Stress (Pa)
time = 1  # Time (s)
angle = 0  # Angle (radians)
incident_angle = math.radians(30)  # Incident angle (radians)
refracted_angle = math.asin((math.sin(math.radians(30)) * 1.5) / 1.0)  # Refracted angle (radians)
velocity = 5  # Velocity (m/s)
velocity1 = 2  # Velocity 1 (m/s)
velocity2 = 4  # Velocity 2 (m/s)
width = 10  # Width (m)
displacement = 0.02  # Displacement (m)
temperature_change = 10  # Temperature change for specific heat capacity (K)
thermal_conductivity = 0.5  # Thermal conductivity (W/(m·K))
characteristic_length = 1.0  # Characteristic length for Nusselt number (m)
convective_heat_transfer = 100  # Convective heat transfer coefficient (W/(m^2·K))
diffusion_coefficient = 0.05  # Diffusion coefficient (m²/s)
concentration_gradient = 0.001  # Concentration gradient (mol/m³)
stefan_boltzmann_constant = 5.67e-8  # Stefan-Boltzmann constant (W/(m²·K⁴))
emissivity = 0.9  # Emissivity (dimensionless)
temperature_surface = 400  # Surface temperature for radiation (K)
temperature_surroundings = 300  # Surrounding temperature for radiation (K)
enthalpy_initial = 1000  # Initial enthalpy for enthalpy change (J)
heat_removed = 250  # Heat removed for coefficient of performance (J)
permeability = 4 * math.pi * 1e-7  # Permeability of material (T·m/A)
cross_sectional_area = 0.01  # Cross-sectional area for inductance (m²)
dielectric_constant = 8.85e-12  # Dielectric constant for capacitance (F/m)
permittivity_free_space = 8.85e-12  # Permittivity of free space for capacitance (F/m)
rate_of_change_electric_field = 0.02  # Rate of change of electric field for displacement current (V/m²)
volume = 0.1  # Volume for volumetric flow rate (m³)
mass_flow_rate = 0.5  # Mass flow rate for volumetric flow rate (kg/s)
specific_volume = 0.001  # Specific volume for mass flow rate (m³/kg)
mass_density = 1000  # Mass density for mass flow rate (kg/m³)
specific_heat_capacity = 4.18  # Specific heat capacity (J/(kg·K))
temperature_initial = 300  # Initial temperature for specific heat (K)
temperature_final = 350  # Final temperature for specific heat (K)
boiling_point = 373.15  # Boiling point for latent heat of vaporization (K)
adiabatic_index = 1.4  # Example value for adiabatic index (specific heat ratio) for air
depth = 10  # Depth (m)

# Conversion functions
def f_to_c(temp_f):
    return (temp_f - 32) * 5/9
def c_to_f(temp_c):
    return (temp_c * 9/5) + 32
dry_bulb_temp_c = f_to_c(dry_bulb_temp)
wet_bulb_temp_c = f_to_c(wet_bulb_temp)
# Display the converted temperatures
dry_bulb_temp_c, wet_bulb_temp_c

# # Convert the variables dictionary to a table format
# variable_table = [["Variable", "Value"]] + [[key, value] for key, value in variables.items()]
# # Print the table for export
# for row in variable_table:
#     print(f"{row[0]: <10} | {row[1]}")


#+END_SRC

#+RESULTS:

* Mechanics of Materials
** Young's Modulus Formula
The formula for Young's Modulus is:
\[ E = \frac{\sigma}{\epsilon} \]
#+BEGIN_SRC python :results output :exports both
# Young's Modulus (Pa)
stress = 200 # Stress (Pa)
strain = 0.01 # Strain (dimensionless)
youngs_modulus = stress / strain
print(f"Young's Modulus: {youngs_modulus} Pa")
youngs_modulus
#+END_SRC

#+RESULTS:
: Young's Modulus: 20000.0 Pa

** Moment of Inertia
The formula for the Moment of Inertia is:
\[ I = \frac{1}{12}bh^3 \]
#+BEGIN_SRC python :results output :exports both
# Moment of Inertia (m^4)
base_length = 1 # Base length (m)
height = 10 # Height (m)
moment_of_inertia = (base_length * height**3) / 12
print(f"Moment of Inertia: {moment_of_inertia} m^4")
moment_of_inertia
#+END_SRC

#+RESULTS:
: Moment of Inertia: 83.33333333333333 m^4

** Polar Moment of Inertia
The formula for the Polar Moment of Inertia is:
\[ J = \frac{\pi}{32}d^4 \]
#+BEGIN_SRC python :results output :exports both
# Polar Moment of Inertia (m^4)
diameter = 0.1 # Diameter (m)
polar_moment_inertia = (math.pi * diameter**4) / 32
print(f"Polar Moment of Inertia: {polar_moment_inertia} m^4")
polar_moment_inertia
#+END_SRC

#+RESULTS:
: Polar Moment of Inertia: 9.817477042468105e-06 m^4

** Axial Deformation
The formula for Axial Deformation is:
\[ \delta L = \frac{FL}{AE} \]
#+BEGIN_SRC python :results output :exports both
# Axial Deformation (m)
force = 50 # Force (N)
length = 0.1 # Length (m)
area = 0.02 # Area (m^2)
youngs_modulus = 2.0e11 # Young's Modulus (Pa)
axial_deformation = (force * length) / (area * youngs_modulus)
print(f"Axial Deformation: {axial_deformation} m")
axial_deformation
#+END_SRC

#+RESULTS:
: Axial Deformation: 1.25e-09 m

** Flexural Stress
The formula for Flexural Stress is:
\[ \sigma = \frac{Mc}{I} \]
#+BEGIN_SRC python :results output :exports both
# Flexural Stress (Pa)
moment = 100 # Moment (N·m)
dist_to_neutral_axis = 0.05 # Distance to neutral axis (m)
moment_of_inertia = 0.0001 # Moment of inertia (m^4)
flexural_stress = (moment * dist_to_neutral_axis) / moment_of_inertia
print(f"Flexural Stress: {flexural_stress} Pa")
flexural_stress
#+END_SRC

#+RESULTS:
: Flexural Stress: 50000.0 Pa

* Thermodynamics
** Entropy Change
The formula for Entropy Change is:
\[ \Delta S = \frac{\Delta Q}{T} \]
#+BEGIN_SRC python :results output :exports both
# Entropy Change (J/K)
delta_Q = 300 # Heat added (J)
temperature = 273.15 # Temperature (K)
delta_S = delta_Q / temperature
print(f"Entropy Change: {delta_S} J/K")
delta_S
#+END_SRC

#+RESULTS:
: Entropy Change: 1.098297638660077 J/K

** First Law of Thermodynamics
The formula for the First Law of Thermodynamics is:
\[ \Delta U = Q - W \]
#+BEGIN_SRC python :results output :exports both
# First Law of Thermodynamics (J)
internal_energy_change = 500 # Internal energy change (J)
heat_added = 300 # Heat added (J)
work_output = 100 # Work output (J)
delta_U = internal_energy_change + heat_added - work_output
print(f"First Law of Thermodynamics: {delta_U} J")
delta_U
#+END_SRC

#+RESULTS:
: First Law of Thermodynamics: 700 J

** Second Law of Thermodynamics
The formula for the Second Law of Thermodynamics is:
\[ \Delta S = \frac{\Delta Q}{T} \]
#+BEGIN_SRC python :results output :exports both
# Second Law of Thermodynamics (J/K)
delta_Q = 300 # Heat added (J)
temperature = 273.15 # Temperature (K)
delta_S = delta_Q / temperature
print(f"Second Law of Thermodynamics: {delta_S} J/K")
delta_S
#+END_SRC

#+RESULTS:
: Second Law of Thermodynamics: 1.098297638660077 J/K

** Ideal Gas Law
The formula for the Ideal Gas Law is:
\[ PV = nRT \]
#+BEGIN_SRC python :results output :exports both
# Ideal Gas Law (Pa·m³ = J)
pressure = 101325 # Pressure (Pa)
volume = 0.1 # Volume (m^3)
gas_constant = 8.314 # Gas constant (J/(mol·K))
temperature = 273.15 # Temperature (K)
substance_amount = 1 # Amount of substance (mol)
ideal_gas_law = pressure * volume - substance_amount * gas_constant * temperature
print(f"Ideal Gas Law: {ideal_gas_law} Pa·m³")
ideal_gas_law
#+END_SRC

#+RESULTS:
: Ideal Gas Law: 7861.5309 Pa·m³

* Fluid Mechanics
** Bernoulli's Equation
The formula for Bernoulli's Equation is:
\[ P + \frac{1}{2}\rho v^2 + \rho gh = \text{constant} \]
#+BEGIN_SRC python :results output :exports both
# Bernoulli's Equation (Pa)
pressure = 101325 # Pressure (Pa)
density = 1000 # Density (kg/m^3)
velocity = 5 # Velocity (m/s)
height = 10 # Height (m)
bernoullis_equation = pressure + (0.5 * density * velocity**2) + (density * gravity * height)
print(f"Bernoulli's Equation: {bernoullis_equation} Pa")
bernoullis_equation
#+END_SRC

#+RESULTS:
: Bernoulli's Equation: 211925.0 Pa

** Volumetric Flow Rate
The formula for Volumetric Flow Rate is:
\[ Q = A \cdot v \]
#+BEGIN_SRC python :results output :exports both
# Volumetric Flow Rate (m^3/s)
area = 0.02 # Area (m^2)
velocity = 5 # Velocity (m/s)
volumetric_flow_rate = area * velocity
print(f"Volumetric Flow Rate: {volumetric_flow_rate} m^3/s")
volumetric_flow_rate
#+END_SRC

#+RESULTS:
: Volumetric Flow Rate: 0.1 m^3/s

* Electricity and Magentism
** Magnetic Field
The formula for Magnetic Field is:
\[ \mathbf{B} = \mu_0 \frac{I}{2\pi r} \]
#+BEGIN_SRC python :results output :exports both
# Magnetic Field (T)
import math
permeability_free_space = 4 * math.pi * 1e-7  # Permeability of free space (T·m/A)
current = 2  # Current (A)
distance = 0.1  # Distance (m)
magnetic_field = permeability_free_space * (current / (2 * math.pi * distance))
print(f"Magnetic Field: {magnetic_field} T")
magnetic_field
#+END_SRC

#+RESULTS:
: Magnetic Field: 4.000000000000001e-06 T

** Voltage
The formula for Voltage (V) is:
V=I⋅RV=I⋅R
#+BEGIN_SRC python :results output :exports both
# Voltage (V)
current = 2  # Current (A)
resistance = 5  # Resistance (Ω)
voltage = current * resistance
print(f"Voltage (V): {voltage} V")
voltage
#+END_SRC

#+RESULTS:
: Voltage (V): 10 V

** Magnetic Flux Density
The formula for Magnetic Flux Density (B) is:
B=μ0⋅I2π⋅rB=2π⋅rμ0​⋅I​
#+BEGIN_SRC python :results output :exports both
# Magnetic Flux Density (B)
permeability_free_space = 4 * math.pi * 1e-7  # Permeability of free space (T·m/A)
current = 2  # Current (A)
radius = 100  # Radius (m)
magnetic_flux_density = permeability_free_space * (current / (2 * math.pi * radius))
print(f"Magnetic Flux Density (B): {magnetic_flux_density} T")
magnetic_flux_density
#+END_SRC

** Magnetic Force
The formula for Magnetic Force (F_m) is:
Fm=N⋅I⋅L⋅BFm​=N⋅I⋅L⋅B
#+BEGIN_SRC python :results output :exports both
# Magnetic Force (F_m)
num_turns = 100  # Number of turns
current = 2  # Current (A)
length_vec = np.array([1, 0, 0])  # Length vector (m)
mag_field_vec = np.array([0.1, 0, 0])  # Magnetic field vector (T)
magnetic_force = num_turns * current * length_vec[0] * mag_field_vec[0]
print(f"Magnetic Force (F_m): {magnetic_force} N")
magnetic_force
#+END_SRC

** Electrostatic Force
The formula for Electrostatic Force (F) is:
F=keq1q2r2F=ke​r2q1​q2​​
#+BEGIN_SRC python :results output :exports both
# Electrostatic Force (F)
coulomb_constant = 8.99e9  # Coulomb constant (N·m^2/C^2)
charge1 = 6  # Charge 1 (C)
charge2 = 3  # Charge 2 (C)
rad_dist_from_wire = 1.58  # Radius (m)
electrostatic_force = coulomb_constant * charge1 * charge2 / rad_dist_from_wire**2
print(f"Electrostatic Force (F): {electrostatic_force} N")
electrostatic_force
#+END_SRC
Certainly! Below is the refactored section of your org-mode Python source code block, containing each formula complete with verbose print statements, organized by the "FE MECHANICAL EXAM" category.

Electricity and Magnetism

Voltage
The formula for Voltage (V) is:
V=I⋅RV=I⋅R

org

#+BEGIN_SRC python :results output :exports both
# Voltage (V)
current = 2  # Current (A)
resistance = 5  # Resistance (Ω)
voltage = current * resistance
print(f"Voltage (V): {voltage} V")
voltage
#+END_SRC

Magnetic Flux Density
The formula for Magnetic Flux Density (B) is:
B=μ0⋅I2π⋅rB=2π⋅rμ0​⋅I​

org

#+BEGIN_SRC python :results output :exports both
# Magnetic Flux Density (B)
permeability_free_space = 4 * math.pi * 1e-7  # Permeability of free space (T·m/A)
current = 2  # Current (A)
radius = 100  # Radius (m)
magnetic_flux_density = permeability_free_space * (current / (2 * math.pi * radius))
print(f"Magnetic Flux Density (B): {magnetic_flux_density} T")
magnetic_flux_density
#+END_SRC

Magnetic Force
The formula for Magnetic Force (F_m) is:
Fm=N⋅I⋅L⋅BFm​=N⋅I⋅L⋅B

org

#+BEGIN_SRC python :results output :exports both
# Magnetic Force (F_m)
num_turns = 100  # Number of turns
current = 2  # Current (A)
length_vec = np.array([1, 0, 0])  # Length vector (m)
mag_field_vec = np.array([0.1, 0, 0])  # Magnetic field vector (T)
magnetic_force = num_turns * current * length_vec[0] * mag_field_vec[0]
print(f"Magnetic Force (F_m): {magnetic_force} N")
magnetic_force
#+END_SRC

Electrostatic Force
The formula for Electrostatic Force (F) is:
F=keq1q2r2F=ke​r2q1​q2​​

org

#+BEGIN_SRC python :results output :exports both
# Electrostatic Force (F)
coulomb_constant = 8.99e9  # Coulomb constant (N·m^2/C^2)
charge1 = 6  # Charge 1 (C)
charge2 = 3  # Charge 2 (C)
rad_dist_from_wire = 1.58  # Radius (m)
electrostatic_force = coulomb_constant * charge1 * charge2 / rad_dist_from_wire**2
print(f"Electrostatic Force (F): {electrostatic_force} N")
electrostatic_force
#+END_SRC

** Inductance (Solenoid)
The formula for Inductance (L) is:
L=μ⋅N2⋅AlL=lμ⋅N2⋅A​
#+BEGIN_SRC python :results output :exports both
# Inductance (Solenoid)
permeability = 4 * math.pi * 1e-7  # Permeability of material (T·m/A)
num_turns = 100  # Number of turns
cross_sectional_area = 0.01  # Cross-sectional area (m²)
length = 0.1  # Length (m)
inductance = (permeability * num_turns**2 * cross_sectional_area) / length
print(f"Inductance (Solenoid): {inductance} H")
inductance
#+END_SRC
** Capacitance (Parallel Plate Capacitor)
The formula for Capacitance (C) is:
C=ε⋅AdC=dε⋅A​
#+BEGIN_SRC python :results output :exports both
# Capacitance (Parallel Plate Capacitor)
dielectric_constant = 8.85e-12  # Dielectric constant (F/m)
permittivity_free_space = 8.85e-12  # Permittivity of free space (F/m)
area = 0.02  # Area (m²)
distance = 0.1  # Distance (m)
capacitance = (dielectric_constant * permittivity_free_space * area) / distance
print(f"Capacitance (Parallel Plate Capacitor): {capacitance} F")
capacitance
#+END_SRC

** Displacement Current (Maxwell's Equations)
The formula for Displacement Current (I_d) is:
Id=ε0∂E∂tId​=ε0​∂t∂E​
#+BEGIN_SRC python :results output :exports both
# Displacement Current (Maxwell's Equations)
permittivity_free_space = 8.85e-12  # Permittivity of free space (F/m)
rate_of_change_electric_field = 0.02  # Rate of change of electric field (V/m²)
displacement_current = permittivity_free_space * rate_of_change_electric_field
print(f"Displacement Current (Maxwell's Equations): {displacement_current} A")
displacement_current
#+END_SRC
** Resistivity
The formula for Resistivity (ρ) is:
ρ=R⋅Alρ=R⋅lA​
#+BEGIN_SRC python :results output :exports both
# Resistivity (Electrical Resistance)
resistance = 5  # Resistance (Ω)
cross_sectional_area = 0.01  # Cross-sectional area (m²)
length = 0.1  # Length (m)
resistivity = resistance * cross_sectional_area / length
print(f"Resistivity (Electrical Resistance): {resistivity} Ω·m")
resistivity
#+END_SRC

#+RESULTS:
: Resistivity (Electrical Resistance): 0.5 Ω·m

* Waves
** Wave Speed
The formula for Wave Speed is:
\[ v = f \cdot \lambda \]
#+BEGIN_SRC python :results output :exports both
# Wave Speed (m/s)
frequency = 50  # Frequency (Hz)
wavelength = 0.5  # Wavelength (m)
wave_speed = frequency * wavelength
print(f"Wave Speed: {wave_speed} m/s")
wave_speed
#+END_SRC

#+RESULTS:
: Wave Speed: 25.0 m/s

** Snell's Law
The formula for Snell's Law is:
\[ n_1 \sin \theta_1 = n_2 \sin \theta_2 \]
#+BEGIN_SRC python :results output :exports both
# Snell's Law
refractive_index1 = 1.5  # Refractive index 1
refractive_index2 = 1.0  # Refractive index 2
incident_angle = math.radians(30)  # Incident angle (radians)
refracted_angle = math.asin((math.sin(incident_angle) * refractive_index1) / refractive_index2)
print(f"Refracted Angle: {math.degrees(refracted_angle)} degrees")
refracted_angle
#+END_SRC

#+RESULTS:
: Refracted Angle: 48.59037789072914 degrees

* Statics
** Equilibrium of a Particle
The conditions for equilibrium of a particle are:
\[ \sum \mathbf{F} = 0 \]
#+BEGIN_SRC python :results output :exports both
# Equilibrium of a Particle (N)
force1 = 50  # Force 1 (N)
force2 = -50  # Force 2 (N)
resultant_force = force1 + force2
print(f"Resultant Force: {resultant_force} N")
resultant_force
#+END_SRC

#+RESULTS:
: Resultant Force: 0 N

** Equilibrium of a Rigid Body
The conditions for equilibrium of a rigid body are:
\[ \sum \mathbf{F} = 0 \quad \text{and} \quad \sum \mathbf{M} = 0 \]
#+BEGIN_SRC python :results output :exports both
# Equilibrium of a Rigid Body (N and N·m)
force1 = 100  # Force 1 (N)
force2 = -100  # Force 2 (N)
moment1 = 30  # Moment 1 (N·m)
moment2 = -30  # Moment 2 (N·m)
resultant_force = force1 + force2
resultant_moment = moment1 + moment2
print(f"Resultant Force: {resultant_force} N")
print(f"Resultant Moment: {resultant_moment} N·m")
resultant_force, resultant_moment
#+END_SRC

#+RESULTS:
: Resultant Force: 0 N
: Resultant Moment: 0 N·m

** Free-Body Diagrams
The process for creating a free-body diagram is:
1. Identify the body to isolate.
2. Represent all forces acting on the body.
3. Include weight, normal force, friction, tension, etc.

** Trusses
The method for analyzing trusses is:
\[ \sum F_x = 0, \quad \sum F_y = 0, \quad \sum M = 0 \]
#+BEGIN_SRC python :results output :exports both
# Analysis of Trusses (N)
joint_force_x = 300  # Force in x-direction (N)
joint_force_y = 400  # Force in y-direction (N)
reaction_force_x = -300  # Reaction force in x-direction (N)
reaction_force_y = -400  # Reaction force in y-direction (N)
resultant_force_x = joint_force_x + reaction_force_x
resultant_force_y = joint_force_y + reaction_force_y
print(f"Resultant Force in x-direction: {resultant_force_x} N")
print(f"Resultant Force in y-direction: {resultant_force_y} N")
resultant_force_x, resultant_force_y
#+END_SRC

#+RESULTS:
: Resultant Force in x-direction: 0 N
: Resultant Force in y-direction: 0 N

** Centroids
The formula for the centroid of a composite area is:
\[ \bar{x} = \frac{\sum A_i x_i}{\sum A_i} \quad \text{and} \quad \bar{y} = \frac{\sum A_i y_i}{\sum A_i} \]
#+BEGIN_SRC python :results output :exports both
# Centroid Calculation (m)
areas = [1, 2, 3]  # Areas (m^2)
x_coords = [1, 2, 3]  # x-coordinates (m)
y_coords = [1, 2, 3]  # y-coordinates (m)
centroid_x = sum(a * x for a, x in zip(areas, x_coords)) / sum(areas)
centroid_y = sum(a * y for a, y in zip(areas, y_coords)) / sum(areas)
print(f"Centroid x-coordinate: {centroid_x} m")
print(f"Centroid y-coordinate: {centroid_y} m")
centroid_x, centroid_y
#+END_SRC

#+RESULTS:
: Centroid x-coordinate: 2.0 m
: Centroid y-coordinate: 2.0 m

** Moments of Inertia
The formulas for the moments of inertia are:
\[ I_x = \int y^2 \, dA \quad \text{and} \quad I_y = \int x^2 \, dA \]
#+BEGIN_SRC python :results output :exports both
# Moment of Inertia (m^4)
base_length = 0.5  # Base length (m)
height = 0.2  # Height (m)
moment_of_inertia_x = (base_length * height**3) / 12
moment_of_inertia_y = (height * base_length**3) / 12
print(f"Moment of Inertia about x-axis: {moment_of_inertia_x} m^4")
print(f"Moment of Inertia about y-axis: {moment_of_inertia_y} m^4")
moment_of_inertia_x, moment_of_inertia_y
#+END_SRC

#+RESULTS:
: Moment of Inertia about x-axis: 0.00013333333333333334 m^4
: Moment of Inertia about y-axis: 0.000004166666666666667 m^4

* Dynamics
** Kinetic Energy
The formula for Kinetic Energy is:
\[ KE = \frac{1}{2}mv^2 \]
#+BEGIN_SRC python :results output :exports both
# Kinetic Energy (J)
mass = 1.0  # Mass (kg)
velocity = 5  # Velocity (m/s)
kinetic_energy = 0.5 * mass * velocity**2
print(f"Kinetic Energy: {kinetic_energy} J")
kinetic_energy
#+END_SRC

#+RESULTS:
: Kinetic Energy: 12.5 J

** Potential Energy
The formula for Potential Energy is:
\[ PE = mgh \]
#+BEGIN_SRC python :results output :exports both
# Potential Energy (J)
mass = 1.0  # Mass (kg)
gravity = 9.81  # Acceleration due to gravity (m/s^2)
height = 10  # Height (m)
potential_energy = mass * gravity * height
print(f"Potential Energy: {potential_energy} J")
potential_energy
#+END_SRC

#+RESULTS:
: Potential Energy: 98.10000000000001 J

* Vibration
** Natural Frequency
The formula for Natural Frequency is:
\[ f_n = \frac{1}{2\pi}\sqrt{\frac{k}{m}} \]
#+BEGIN_SRC python :results output :exports both
# Natural Frequency (Hz)
spring_constant = 100  # Spring constant (N/m)
mass = 1.0  # Mass (kg)
natural_frequency = (1 / (2 * math.pi)) * math.sqrt(spring_constant / mass)
print(f"Natural Frequency: {natural_frequency} Hz")
natural_frequency
#+END_SRC

#+RESULTS:
: Natural Frequency: 1.5915494309189535 Hz

** Damping Ratio
The formula for Damping Ratio is:
\[ \zeta = \frac{c}{2\sqrt{km}} \]
#+BEGIN_SRC python :results output :exports both
# Damping Ratio (dimensionless)
damping_coefficient = 10  # Damping coefficient (N·s/m)
damping_ratio = damping_coefficient / (2 * math.sqrt(spring_constant * mass))
print(f"Damping Ratio: {damping_ratio}")
damping_ratio
#+END_SRC

#+RESULTS:
: Damping Ratio: 0.5

* Control Systems
** Transfer Function
The formula for Transfer Function is:
\[ H(s) = \frac{Y(s)}{X(s)} \]
#+BEGIN_SRC python :results output :exports both
# Transfer Function
import control as ctrl
numerator = [1]  # Numerator coefficients
denominator = [1, 2, 1]  # Denominator coefficients
transfer_function = ctrl.TransferFunction(numerator, denominator)
print(f"Transfer Function:\n{transfer_function}")
transfer_function
#+END_SRC

#+RESULTS:
: Transfer Function:
: <TransferFunction>: sys[0]
: Inputs (1): ['u[0]']
: Outputs (1): ['y[0]']
:
:
:       1
: -------------
: s^2 + 2 s + 1

* Probability and Statistics
** Mean
The formula for Mean is:
\[ \mu = \frac{\sum x_i}{n} \]
#+BEGIN_SRC python :results output :exports both
# Mean
data = [1, 2, 3, 4, 5]  # Data points
mean = sum(data) / len(data)
print(f"Mean: {mean}")
mean
#+END_SRC

#+RESULTS:
: Mean: 3.0

** Standard Deviation
The formula for Standard Deviation is:
\[ \sigma = \sqrt{\frac{\sum (x_i - \mu)^2}{n}} \]
#+BEGIN_SRC python :results output :exports both
# Standard Deviation
mean = sum(data) / len(data)
variance = sum((x - mean) ** 2 for x in data) / len(data)
standard_deviation = math.sqrt(variance)
print(f"Standard Deviation: {standard_deviation}")
standard_deviation
#+END_SRC

#+RESULTS:
: Standard Deviation: 1.4142135623730951

** Probability Density Function
The formula for Probability Density Function is:
\[ f(x) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}} \]
#+BEGIN_SRC python :results output :exports both
# Probability Density Function
x = 3  # Data point
mean = 0  # Mean
std_dev = 1  # Standard deviation
pdf = (1 / (math.sqrt(2 * math.pi * std_dev**2))) * math.exp(-((x - mean)**2 / (2 * std_dev**2)))
print(f"PDF at x={x}: {pdf}")
pdf
#+END_SRC

#+RESULTS:
: PDF at x=3: 0.0044318484119380075

* Engineering Economics
#+BEGIN_SRC python :results output :exports both
A = 12000  # Uniform amount per interest period
B = 0.0  # Benefit
BV = 0.0  # Book value
C = 40000  # Cost
d = 0.0  # Inflation adjusted interest rate per interest period
Dj = 0.0  # Depreciation in year j
EV = 0.0  # Expected value
f = 0.0  # General inflation rate per interest period
MARR = 0.0  # Minimum acceptable/attractive rate of return
m = 0  # Number of compounding periods per year
P = 0.0  # Present worth, value, or amount
r = 0.0  # Nominal annual interest rate
Sn = 0.0  # Expected salvage value in year n

# Interest rate per interest period
i = 0.1  # Interest rate per interest period, example: 0.1 for 10%
n = 5  # Number of compounding periods; or the expected life of an asset
P_single_payment = 1000  # Given Present worth
F_present_worth = 1500  # Given Future worth
F_single_payment = 2000  # Future worth to be calculated
P_capital_recovery = 1000  # Given Present worth for Capital Recovery
A_uniform_series = 150  # Given Uniform amount per interest period
G_uniform_gradient = 50  # Given Uniform Gradient

# Define the necessary financial functions

def single_payment_compound_amount(P, i, n):
    """
    Calculate Single Payment Compound Amount (F/P, i%, n)
    """
    return P * (1 + i)**n

def single_payment_present_worth(F, i, n):
    """
    Calculate Single Payment Present Worth (P/F, i%, n)
    """
    return F / (1 + i)**n

def uniform_series_sinking_fund(F, i, n):
    """
    Calculate Uniform Series Sinking Fund (A/F, i%, n)
    """
    return F * (i / ((1 + i)**n - 1))

def capital_recovery(P, i, n):
    """
    Calculate Capital Recovery (A/P, i%, n)
    """
    return P * (i * (1 + i)**n) / ((1 + i)**n - 1)

def linear_interpolation(x0, x1, y0, y1, x):
    """
    Perform linear interpolation between (x0, y0) and (x1, y1) for a given x
    """
    return y0 + (y1 - y0) * ((x - x0) / (x1 - x0))

def calculate_ror(initial_cost, annual_savings, operational_cost, life_expectancy, interest_rates, factors):
    """
    Calculate Rate of Return (ROR)
    """
    annual_net_savings = annual_savings - operational_cost
    expenses = initial_cost

    # Calculate the capital recovery factor
    factors_at_interest_rates = [capital_recovery(1, i, life_expectancy) for i in interest_rates]

    # Interpolate between two interest rates
    expense_factor = expenses / annual_net_savings

    # Find interest rate where our expense_factor approximates
    for i in range(len(interest_rates) - 1):
        if factors_at_interest_rates[i] <= expense_factor <= factors_at_interest_rates[i + 1]:
            ROR = linear_interpolation(factors_at_interest_rates[i],
                                        factors_at_interest_rates[i + 1],
                                        interest_rates[i],
                                        interest_rates[i + 1],
                                        expense_factor)
            return ROR

    return None

# Example Usage

# Given Values
initial_cost = 40000
annual_savings = 15000
operational_cost = 3000
life_expectancy = 5
interest_rates = [0.12, 0.18]  # Example interest rates (12%, 18%)
factors = [4.111, 3.127]  # Example factors for these interest rates

# ROR Calculation
rate_of_return = calculate_ror(initial_cost, annual_savings, operational_cost, life_expectancy, interest_rates, factors)
print(f"Rate of Return (ROR): {rate_of_return*100:.2f}%")

# Single Payment Compound Amount (F/P, i%, n)
F_single_payment = P_single_payment * (1 + i)**n
print(f"Single Payment Compound Amount (F/P, i%, n): {F_single_payment}")

# Single Payment Present Worth (P/F, i%, n)
P_present_worth = F_present_worth / (1 + i)**n
print(f"Single Payment Present Worth (P/F, i%, n): {P_present_worth}")

# Uniform Series Sinking Fund (A/F, i%, n)
A_sinking_fund = F_single_payment * (i / ((1 + i)**n - 1))
print(f"Uniform Series Sinking Fund (A/F, i%, n): {A_sinking_fund}")

# Capital Recovery (A/P, i%, n)
A_capital_recovery = P_capital_recovery * (i * (1 + i)**n) / ((1 + i)**n - 1)
print(f"Capital Recovery (A/P, i%, n): {A_capital_recovery}")

# Uniform Series Compound Amount (F/A, i%, n)
F_uniform_series = A_uniform_series * (((1 + i)**n - 1) / i)
print(f"Uniform Series Compound Amount (F/A, i%, n): {F_uniform_series}")

# Uniform Series Present Worth (P/A, i%, n)
P_uniform_series = A_uniform_series * ((1 - (1 + i)**-n) / i)
print(f"Uniform Series Present Worth (P/A, i%, n): {P_uniform_series}")

# Uniform Gradient Present Worth (P/G, i%, n)
P_uniform_gradient = G_uniform_gradient * (((1 + i)**n - n * i - 1) / (i**2 * (1 + i)**n))
print(f"Uniform Gradient Present Worth (P/G, i%, n): {P_uniform_gradient}")

# Uniform Gradient Future Worth (F/G, i%, n)
F_uniform_gradient = G_uniform_gradient * (((1 + i)**n - 1 - n * i) / i)
print(f"Uniform Gradient Future Worth (F/G, i%, n): {F_uniform_gradient}")

# Uniform Gradient Uniform Series (A/G, i%, n)
A_gradient_series = G_uniform_gradient * (1 / i - n / ((1 + i)**n - 1))
print(f"Uniform Gradient Uniform Series (A/G, i%, n): {A_gradient_series}")
#+END_SRC

#+BEGIN_SRC python :results output :exports both
def single_payment_compound_amount(P, i, n):
    """
    Calculate Single Payment Compound Amount (F/P, i%, n)
    """
    return P * (1 + i)**n

def single_payment_present_worth(F, i, n):
    """
    Calculate Single Payment Present Worth (P/F, i%, n)
    """
    return F / (1 + i)**n

def uniform_series_sinking_fund(F, i, n):
    """
    Calculate Uniform Series Sinking Fund (A/F, i%, n)
    """
    return F * (i / ((1 + i)**n - 1))

def capital_recovery(P, i, n):
    """
    Calculate Capital Recovery (A/P, i%, n)
    """
    return P * (i * (1 + i)**n) / ((1 + i)**n - 1)

def linear_interpolation(x0, x1, y0, y1, x):
    """
    Perform linear interpolation between (x0, y0) and (x1, y1) for a given x
    """
    return y0 + (y1 - y0) * ((x - x0) / (x1 - x0))

def calculate_ror(initial_cost, annual_savings, operational_cost, life_expectancy, interest_rates, factors):
    """
    Calculate Rate of Return (ROR)
    """
    annual_net_savings = annual_savings - operational_cost
    expenses = initial_cost

    # Calculate the capital recovery factor
    factors_at_interest_rates = [capital_recovery(1, i, life_expectancy) for i in interest_rates]

    # Interpolate between two interest rates
    expense_factor = expenses / annual_net_savings

    # Find interest rate where our expense_factor approximates
    for i in range(len(interest_rates) - 1):
        if factors_at_interest_rates[i] <= expense_factor <= factors_at_interest_rates[i + 1]:
            ROR = linear_interpolation(factors_at_interest_rates[i],
                                        factors_at_interest_rates[i + 1],
                                        interest_rates[i],
                                        interest_rates[i + 1],
                                        expense_factor)
            return ROR

    return None

# Example Usage

# Given Values
initial_cost = 40000
annual_savings = 15000
operational_cost = 3000
life_expectancy = 5
interest_rates = [0.12, 0.18]  # Example interest rates (12%, 18%)
factors = [4.111, 3.127]  # Example factors for these interest rates

# ROR Calculation
rate_of_return = calculate_ror(initial_cost, annual_savings, operational_cost, life_expectancy, interest_rates, factors)
print(f"Rate of Return (ROR): {rate_of_return*100:.2f}%")
#+end_src

* TODO
** Previous Print Statements
# print(f"\n::Mechanics of Materials::")
# # Calculate Stress (sigma)
# sigma = variables["force"] / variables["area"]
# print(f"Stress (sigma): {sigma} Pa")
# # Calculate Strain (epsilon)
# epsilon = variables["delta_length"] / variables["length"]
# print(f"Strain (epsilon): {epsilon}")
# # Calculate Young's Modulus (E)
# E = variables["stress"] / variables["strain"]
# print(f"Young's Modulus (E): {E} Pa")
# # Calculate Shear Stress (tau)
# tau = variables["force"] / variables["area"]
# print(f"Shear Stress (tau): {tau} Pa")
# # Calculate Shear Strain (gamma)
# gamma = variables["delta_displacement"] / variables["height"]
# print(f"Shear Strain (gamma): {gamma}")
# # Calculate Bending Stress
# bending_stress = variables["moment"] * variables["dist_to_neutral_axis"] / variables["moment_of_inertia"]
# print(f"Bending Stress: {bending_stress} Pa")
# # Calculate Torsional Shear Stress
# torsional_shear_stress = variables["torque"] * variables["radius"] / variables["polar_moment_inertia"]
# print(f"Torsional Shear Stress: {torsional_shear_stress} Pa")
# # Calculate Poisson's Ratio (v)
# poisson_ratio = -variables["lateral_strain"] / variables["longitudinal_strain"]
# print(f"Poisson's Ratio (v): {poisson_ratio}")
# # Calculate Second Moment of Inertia (Rectangle about centroid)
# I = (variables["width"] * variables["height"]**3) / 12
# print(f"Second Moment of Inertia: {I} m^4")


# print(f"\n::Fluid Mechanics::")
# # Calculate Pressure (P)
# P = variables["density"] * variables["gravity"] * variables["height"]
# print(f"Pressure (P): {P} Pa")
# # Calculate Flow Rate
# flow_rate = variables["area1"] * variables["velocity1"]
# print(f"Flow Rate: {flow_rate} m^3/s")
# # Calculate Reynolds Number
# Re = variables["density"] * variables["velocity"] * variables["diameter"] / variables["viscosity"]
# print(f"Reynolds Number: {Re}")
# # Calculate Nusselt Number
# Nu = variables["convective_heat_transfer"] * variables["characteristic_length"] / variables["thermal_conductivity"]
# print(f"Nusselt Number: {Nu}")
# # Calculate Stokes' Law (Viscous Drag on a Sphere)
# stokes_law = 6 * math.pi * variables["viscosity"] * variables["radius"] * variables["velocity"]
# print(f"Stokes' Law (Viscous Drag on a Sphere): {stokes_law}")
# # Calculate Strouhal Number (Flow past a Cylinder)
# St = variables["frequency"] * variables["characteristic_length"] / variables["velocity"]
# print(f"Strouhal Number: {St}")
# # Calculate Bernoulli Equation Pressure Difference
# rho = variables["density"]
# v1 = variables["velocity1"]
# v2 = variables["velocity2"]
# P1 = variables["pressure"]
# P2 = P1 + 0.5 * rho * (v1**2 - v2**2)
# print(f"Pressure Difference (Bernoulli): {P2 - P1} Pa")


# print(f"\n::Thermodynamics::")
# # Ideal Gas Law calculation
# ideal_gas = variables["substance_amount"] * variables["gas_constant"] * variables["temperature"]
# print(f"Ideal Gas Law: {ideal_gas} J/mol")
# # Calculate Efficiency (eta)
# eta = variables["work_output_out"] / variables["heat_input"]
# print(f"Efficiency (eta): {eta}")
# # Calculate Specific Heat Capacity
# specific_heat_capacity = variables["heat_added"] / (variables["mass"] * variables["temperature_change"])
# print(f"Specific Heat Capacity: {specific_heat_capacity}")
# # Calculate Coefficient of Performance (Refrigeration Cycle)
# COP = variables["heat_removed"] / variables["work_output_in"]
# print(f"Coefficient of Performance (Refrigeration Cycle): {COP}")
# # Calculate Heat Transfer by Radiation (Stefan-Boltzmann Law)
# radiative_heat_transfer = variables["stefan_boltzmann_constant"] * variables["emissivity"] * (variables["temperature_surface"]**4 - variables["temperature_surroundings"]**4) * variables["area"]
# print(f"Heat Transfer by Radiation (Stefan-Boltzmann Law): {radiative_heat_transfer}")
# # Calculate Change in Internal Energy (delta_U)
# delta_U = variables["heat_added"] - variables["work_output_out"]
# print(f"Change in Internal Energy (delta_U): {delta_U} J")
# # Calculate Change in Enthalpy (delta_H)
# delta_H = variables["enthalpy_initial"] + variables["delta_KE"] + variables["delta_PE"] + variables["delta_S"]
# print(f"Change in Enthalpy (delta_H): {delta_H} J")
# # Calculate Efficiency using Carnot Cycle (eta_carnot)
# eta_carnot = 1 - variables["low_temp"] / variables["high_temp"]
# print(f"Carnot Cycle Efficiency (eta_carnot): {eta_carnot}")
# # Calculate Latent Heat of Vaporization (h_fg)
# h_fg = variables["spec_heat_capacity_cp"] * (variables["boiling_point"] - variables["initial_temp"])
# print(f"Latent Heat of Vaporization (h_fg): {h_fg} kJ/kg")


# print(f"\n::Dynamics and Kinematics::")
# # Calculate Potential Energy (PE)
# PE = variables["mass"] * variables["gravity"] * variables["height"]
# print(f"Potential Energy (PE): {PE} J")
# # Calculate Kinetic Energy (KE)
# KE = 0.5 * variables["mass"] * variables["velocity"]**2
# print(f"Kinetic Energy (KE): {KE} J")
# # Calculate Work (W)
# W = variables["force"] * variables["distance"] * math.cos(variables["angle"])
# print(f"Work (W): {W} J")
# # Calculate Centripetal Force (Fc)
# Fc = variables["mass"] * variables["velocity"]**2 / variables["radius"]
# print(f"Centripetal Force (Fc): {Fc} N")
# # Calculate Angular Velocity (omega)
# omega = variables["angle"] / variables["time"]
# print(f"Angular Velocity (omega): {omega} rad/s")
# # Calculate Wave Speed (v)
# wave_speed = variables["frequency"] * variables["wavelength"]
# print(f"Wave Speed (v): {wave_speed} m/s")


# print(f"\n::Electricity and Magnetism::")
# # Calculate Voltage (V)
# V = variables["current"] * variables["resistance"]
# print(f"Voltage (V): {V} V")
# # Calculate Magnetic Flux Density (B)
# B = variables["permeability_free_space"] * variables["current"] / (2 * math.pi * variables["radius"])
# print(f"Magnetic Flux Density (B): {B} T")
# # Calculate Magnetic Force (F_m)
# F_m = variables["num_turns"] * variables["current"] * variables["length_vec"][0] * variables["mag_field_vec"][0]
# print(f"Magnetic Force (F_m): {F_m} N")
# # Calculate Electrostatic Force (F)
# electrostatic_force = variables["coulomb_constant"] * variables["charge1"] * variables["charge2"] / variables["rad_dist_from_wire"]**2
# print(f"Electrostatic Force (F): {electrostatic_force} N")
# # Calculate Inductance (Solenoid)
# inductance = (variables["permeability"] * variables["num_turns"]**2 * variables["cross_sectional_area"]) / variables["length"]
# print(f"Inductance (Solenoid): {inductance}")
# # Calculate Capacitance (Parallel Plate Capacitor)
# capacitance = (variables["dielectric_constant"] * variables["permittivity_free_space"] * variables["area"]) / variables["distance"]
# print(f"Capacitance (Parallel Plate Capacitor): {capacitance}")
# # Calculate Displacement Current (Maxwell's equations)
# displacement_current = variables["permittivity_free_space"] * variables["rate_of_change_electric_field"]
# print(f"Displacement Current (Maxwell's equations): {displacement_current}")
# # Calculate Resistivity (Electrical Resistance)
# resistivity = variables["resistance"] * variables["cross_sectional_area"] / variables["length"]
# print(f"Resistivity (Electrical Resistance): {resistivity}")


# print(f"\n::Material Properties::")
# # Calculate Linear Expansion (delta_L)
# delta_L = variables["length"] * variables["strain"]
# print(f"Linear Expansion (delta_L): {delta_L} m")
# # Calculate Volume Expansion (delta_V)
# alpha = 1 / (variables["spec_heat_capacity_cv"] * variables["temperature"])
# delta_V = alpha * variables["volume"] * variables["temp_difference"]
# print(f"Volume Expansion (delta_V): {delta_V} m^3")


# print(f"\n::Fluid and Thermal Systems::")
# # Function for saturation vapor pressure calculation
# def saturation_vapor_pressure(T):
#     T_C = (T - 32) * 5.0 / 9.0  # Convert °F to °C
#     return 6.112 * math.exp((17.67 * T_C) / (T_C + 243.5))
# # Calculate saturation vapor pressure
# T = variables["temperature"]  # Example temperature in °F
# saturation_vapor_pressure_value = saturation_vapor_pressure(T)
# print(f"Saturation Vapor Pressure at {T} °F: {saturation_vapor_pressure_value} hPa")
# # Calculate specific heat
# specific_heat = variables["heat_added"] / (variables["mass"] * variables["temperature_change"])
# specific_heat
# print(f"Specific Heat: {specific_heat} J/(kg·K)")
# # Calculate Fourier's Law (Heat Conduction)
# heat_conduction = variables["thermal_conductivity"] * variables["area"] * (variables["temperature_change"] / variables["length"])
# print(f"Fourier's Law (Heat Conduction): {heat_conduction} W")
# # Calculate Diffusion Equation (Mass Transfer)
# diffusion_flux = -variables["diffusion_coefficient"] * (variables["concentration_gradient"] / variables["distance"])
# print(f"Diffusion Equation (Mass Transfer): {diffusion_flux} kg/(m²·s)")


# print(f"\n::Additional Physics::")
# # Calculate Speed of Sound in a Gas
# speed_of_sound = math.sqrt(variables["adiabatic_index"] * variables["gas_constant"] * variables["temperature"])
# print(f"Speed of Sound in a Gas: {speed_of_sound} m/s")
# # Calculate Pascal's Law (Hydrostatic Pressure)
# hydrostatic_pressure = variables["fluid_density"] * variables["gravity"] * variables["depth"]
# print(f"Hydrostatic Pressure (Pascal's Law): {hydrostatic_pressure} Pa")

# # Function to calculate permutations
# def permutations(n, r):
#     """
#     Calculate the number of permutations of n distinct objects taken r at a time.
#     Parameters:
#     n (int): Total number of distinct objects.
#     r (int): Number of objects taken at a time.
#     Returns:
#     int: Number of permutations.
#     """
#     return math.factorial(n) // math.factorial(n - r)

# # Function to calculate combinations
# def combinations(n, r):
#     """
#     Calculate the number of combinations of n distinct objects taken r at a time.
#     Parameters:
#     n (int): Total number of distinct objects.
#     r (int): Number of objects taken at a time.
#     Returns:
#     int: Number of combinations.
#     """
#     return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))
# # Example calculations
# n = 10
# r = 1
# nPr = permutations(n, r)
# nCr = combinations(n, r)
# print(f"Permutations P({n}, {r}): {nPr}")
# print(f"Combinations C({n}, {r}): {nCr}")
** Reference Handbook Category Scores
#+BEGIN_SRC python :results output :exports both
import pandas as pd

data = {
    "Knowledge Area": ["Mathematics", "Probability and Statistics", "Ethics and Professional Practice", "Engineering Economics", "Electricity and Magnetism", "Statics", "Dynamics, Kinematics, and Vibrations", "Mechanics of Materials", "Material Properties and Processing", "Fluid Mechanics", "Thermodynamics", "Heat Transfer", "Measurements, Instrumentation, and Controls", "Mechanical Design and Analysis"],
    "Number of Items": [6, 4, 4, 4, 5, 9, 10, 9, 7, 10, 10, 7, 5, 10],
    "Performance": [10.3, 6.2, 8.5, 6.8, 5.6, 8.5, 7.1, 4.5, 7.9, 6.7, 6.4, 6.9, 10.0, 6.7]
}

df = pd.DataFrame(data)

df['Percentage Score'] = df['Performance'] / df['Number of Items'] * 100
df = df.sort_values(by='Percentage Score', ascending=False)
print(f"Dataframe (df): {df} df")
df
#+end_src

#+RESULTS:
#+begin_example
Dataframe (df):                                  Knowledge Area  ...  Percentage Score
2              Ethics and Professional Practice  ...        212.500000
12  Measurements, Instrumentation, and Controls  ...        200.000000
0                                   Mathematics  ...        171.666667
3                         Engineering Economics  ...        170.000000
1                    Probability and Statistics  ...        155.000000
8            Material Properties and Processing  ...        112.857143
4                     Electricity and Magnetism  ...        112.000000
11                                Heat Transfer  ...         98.571429
5                                       Statics  ...         94.444444
6          Dynamics, Kinematics, and Vibrations  ...         71.000000
13               Mechanical Design and Analysis  ...         67.000000
9                               Fluid Mechanics  ...         67.000000
10                               Thermodynamics  ...         64.000000
7                        Mechanics of Materials  ...         50.000000

[14 rows x 4 columns] df
#+end_example
